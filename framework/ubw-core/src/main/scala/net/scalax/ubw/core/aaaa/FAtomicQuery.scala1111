package net.scalax.fsn.core

import scala.language.higherKinds
import scala.reflect.runtime.universe._
import shapeless._
/*trait AtomicQueryBase {
  self =>

  val path: AtomicPath

  def commonWithRep[E, V, X, F, K](rep: E)(everywherePoly: Poly, everythingPoly: EverythingAux[F, K])(
    implicit
    case1: Lazy[poly.Case1.Aux[everywherePoly.type, E, V]],
    listCase: Lazy[poly.Case1.Aux[everythingPoly.type, E, X]],
    cv: Lazy[X <:< List[AbstractAtomicGen[path.DataType, Any]]]
  ): WithRep[V] = {
    new WithRep[V] {
      override val queryResult = {
        try {
          Right(everywherePoly.apply(rep)(case1.value))
        } catch {
          case e: AtomicException =>
            //过滤出全部 Atomic 中没有的 Reader 的 TypeTag
            val atomicGenList = cv.value(
              everythingPoly
                .apply(rep)(listCase.value)
            )
            val missTypeTags = atomicGenList.map { gen =>
              gen.getBy(path.atomics) match {
                case Left(e) => Option(e)
                case _ => None
              }
            }.collect { case Some(s) => s.typeTags }.flatten
            Left(AtomicException(missTypeTags))
        }
      }
    }
  }

  trait WithRep[A] {
    val queryResult: Either[AtomicException, A]

    def mapTo[C[_], R](cv: (A, C[path.DataType]) => R): QueryTranform[R, C] = {
      new QueryTranform[R, C] {
        override type QueryType = A
        override lazy val path: self.path.type = self.path
        override val gen = queryResult
        override def apply(rep: A, data: C[path.DataType]): R = {
          cv(rep, data)
        }
      }
    }

    def mapToOption[R](cv: (A, Option[path.DataType]) => R): QueryTranform[R, Option] = mapTo[Option, R](cv)

    def mapToWithoutData[C[_], R](cv: A => R): QueryTranformWithOutData[R, C] = {
      new QueryTranformWithOutData[R, C] {
        override type QueryType = A
        override val gen = queryResult
        override def apply(rep: A): R = {
          cv(rep)
        }
      }
    }

    def mapToOptionWithoutData[R](cv: A => R): QueryTranformWithOutData[R, Option] = mapToWithoutData[Option, R](cv)
  }

}

trait AtomicQueryImpl extends AtomicQueryBase {
  self =>

  object AtomicGenPolyImpl extends AtomicGenPolyImpl[path.type](path)
  val everywhereAtomicGenPoly = everywhere(AtomicGenPolyImpl)

  object everythingAtomicListPoly extends AtomicListPolyImpl[path.type](path)
  object everythingAtomicAppend extends AtomicAppendImpl[path.type](path)
  val everythingImpl = everything(everythingAtomicListPoly).apply(everythingAtomicAppend)

  def withRep[E, V, X](rep: E)(
    implicit
    case1: Lazy[poly.Case1.Aux[everywhereAtomicGenPoly.type, E, V]],
    listCase: Lazy[poly.Case1.Aux[everythingImpl.type, E, X]],
    cv: Lazy[X <:< List[AbstractAtomicGen[path.DataType, Any]]]
  ): WithRep[V] = {
    commonWithRep(rep)(everywhereAtomicGenPoly, everythingImpl)(case1, listCase, cv)
  }

  def needAtomic[T[_]](implicit parGen: AtomicPartialFunctionGen[T], typeTag: WeakTypeTag[T[_]]): AbstractAtomicGen[path.DataType, T[path.DataType]] = AtomicGenHelper.needAtomic[path.DataType, T](parGen, typeTag)
  def needAtomicOpt[T[_]](implicit parGen: AtomicPartialFunctionGen[T]): AbstractAtomicGen[path.DataType, Option[T[path.DataType]]] = AtomicGenHelper.needAtomicOpt[path.DataType, T](parGen)
  def needAtomicList[T[_]](implicit parGen: AtomicPartialFunctionGen[T]): AbstractAtomicGen[path.DataType, List[T[path.DataType]]] = AtomicGenHelper.needAtomicList[path.DataType, T](parGen)

}

trait AtomicGenPoly extends Poly1 {

  val path: AtomicPath

  implicit def intCase[S]: Case.Aux[AbstractAtomicGen[path.DataType, S], S] = {
    at { s =>
      s.getBy(path.atomics) match {
        case Left(e) => throw e
        case Right(t) => t
      }
    }
  }

}

class AtomicGenPolyImpl[T <: AtomicPath](override val path: T) extends AtomicGenPoly

trait AtomicListPoly extends Poly1 {

  val path: AtomicPath

  implicit def default[T] = at[T](_ => List.empty[AbstractAtomicGen[path.DataType, Any]])

  implicit def intCase[S]: Case.Aux[AbstractAtomicGen[path.DataType, S], List[AbstractAtomicGen[path.DataType, Any]]] = {
    at(s => s.asInstanceOf[AbstractAtomicGen[path.DataType, Any]] :: Nil)
  }

}

class AtomicListPolyImpl[T <: AtomicPath](override val path: T) extends AtomicListPoly

trait AtomicAppend extends Poly2 {
  val path: AtomicPath

  implicit def caseString = at[List[AbstractAtomicGen[path.DataType, Any]], List[AbstractAtomicGen[path.DataType, Any]]](_ ++ _)
}

class AtomicAppendImpl[T <: AtomicPath](override val path: T) extends AtomicAppend

class AtomicQuery(override val path: AtomicPath) extends AtomicQueryImpl*/
trait QueryTranform[U, C[_]] {
  type QueryType
  val path: AtomicPath
  val gen: Either[AtomicException, QueryType]
  def apply(rep: QueryType, data: C[path.DataType]): U
}

trait QueryTranformWithOutData[U, C[_]] {
  type QueryType
  val gen: Either[AtomicException, QueryType]
  def apply(rep: QueryType): U
}

trait AtomicQueryImpl {
  self =>

  val path: AtomicPath

  val FANil: AbstractAtomicGen[path.DataType, HNil] = AbstractAtomicGen.empty

  def withRep[F](rep: AbstractAtomicGen[path.DataType, F]): WithRep[F] = {
    new WithRep[F] {
      override val queryResult: Either[AtomicException, F] = {
        rep.getBy(path.atomics)
      }
    }
  }

  trait WithRep[A] {
    val queryResult: Either[AtomicException, A]

    def mapTo[C[_], R](cv: (A, C[path.DataType]) => R): QueryTranform[R, C] = {
      new QueryTranform[R, C] {
        override type QueryType = A
        override lazy val path: self.path.type = self.path
        override val gen = queryResult
        override def apply(rep: A, data: C[path.DataType]): R = {
          cv(rep, data)
        }
      }
    }

    def mapToOption[R](cv: (A, Option[path.DataType]) => R): QueryTranform[R, Option] = mapTo[Option, R](cv)

    def mapToWithoutData[C[_], R](cv: A => R): QueryTranformWithOutData[R, C] = {
      new QueryTranformWithOutData[R, C] {
        override type QueryType = A
        override val gen = queryResult
        override def apply(rep: A): R = {
          cv(rep)
        }
      }
    }

    def mapToOptionWithoutData[R](cv: A => R): QueryTranformWithOutData[R, Option] = mapToWithoutData[Option, R](cv)
  }

  def needAtomic[T[_]](implicit parGen: AtomicPartialFunctionGen[T], typeTag: WeakTypeTag[T[_]]): AbstractAtomicGen[path.DataType, T[path.DataType]] = AtomicGenHelper.needAtomic[path.DataType, T](parGen, typeTag)
  def needAtomicOpt[T[_]](implicit parGen: AtomicPartialFunctionGen[T]): AbstractAtomicGen[path.DataType, Option[T[path.DataType]]] = AtomicGenHelper.needAtomicOpt[path.DataType, T](parGen)
  def needAtomicList[T[_]](implicit parGen: AtomicPartialFunctionGen[T]): AbstractAtomicGen[path.DataType, List[T[path.DataType]]] = AtomicGenHelper.needAtomicList[path.DataType, T](parGen)

}

class AtomicQuery(override val path: AtomicPath) extends AtomicQueryImpl