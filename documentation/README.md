关于如何构建基于列声明的无 Model 系统的一些想法
===
&emsp;&emsp;鉴于 linux deepin 的中文输入法限制,本文暂时采用英文标点.另:如果想提交 issue,请用英文.

#一般 MVC 模式
&emsp;&emsp;最近两年写增删查改写得郁闷,然后开始思考如何把代码缩到最短,最初的灵感来源于 @jilen 对我写的
slick 动态 insert 的一个思路整理 https://github.com/scalax/hf/pull/5 ,虽然现在无论是 api
还是内部实现(内部现在用 ListAnyShape 实现,简单高效)都已经面目全非了,但核心的东西一直没变,此后一年的业余时间都在这方面工作.
现在把到目前的成果分享一下.

&emsp;&emsp;问题的开端源于对 MVC 模式的一些思考,首先我们来看看,要做一个增删查改, MVC 模式所需要的东西是哪些?

&emsp;&emsp;首先我们需要建立一个数据库(以 H2 为例)的表,用来存储我们的数据,
```sql
create table "firend" (
    "id" BIGINT GENERATED BY DEFAULT AS IDENTITY(START WITH 1) NOT NULL,
    "name" VARCHAR NOT NULL,
    "nick" VARCHAR NOT NULL
)
```
注意: id 列是自增的,我们在插入的时候不需要插入这一列的数据.
如果我们是用 Java Hibernate 的话,就需要用 JPA 进行建模了,代码可能是下面这样的:
```java
@Entity
public class Friend implements Serializable {
    private static final long serialVersionUID = 1L;
    
    @Id @GeneratedValue
    private long id;
    
    private String name;
    private String nick;
    
    public Friend() {
    }
    
    Friend(String name, String nick) {
        this.name = name;
        this.nick = nick;
    }
    
    public Long getId() {
        return id;
    }
    
    public String getName() {
        return nick;
    }
    
    public String getNick() {
        return nick;
    }
    
    @Override
    public String toString() {
        return String.format("Friend(%d, %d)", this.getName(), this.getNick());
    }
}
```
然后就需要写一个 Dao 类了,在 Spring 中这个也不难,可以有一个 Abstract Dao,普通的 Dao
如果没有什么需要修改的话直接继承即可.再写一个 Controller,写好增删查改的逻辑,再把你需要和浏览器交互的数据是 Json
格式这一点显式或者隐式地标记一下, Java 这边的工作就做完了.
在浏览器端的话你可能选用 Dojo 这个老牌的框架,然而无论选择哪种框架,做这种千篇一律的 CRUD 的工作应该都差不多,在建好
Table 对象之后,除了匹配 Url 的格式,你还需要匹配每一列的数据类型,于是下面那一段代码你是不能够省略的:
```javascript
var layout = [[
    { "name": "Id", "field": "id" },
    { "name": "姓名", "field": "name" },
    { "name": "昵称", "field": "nick" }
]];
```
花了一大番功夫,你终于做完了一个增删查改,然而还有 100 个增删查改,而且这些增删查改除了字段不同,逻辑有一些会有特殊要求之外,
好像没什么需要特殊处理的地方了,本文就是探求一种方法,如何简化这种千篇一律的操作.

在此先提醒一下,对于一些有相当复杂度的操作,可能本文所提到的模型并不适合,
这个模型目前的进度只适合于那些千篇一律而且会有部分特殊需求的数据转换,
但本文的讨论对象不单单只是数据库操作,还包括 Json 转换和 Excel 操作(POI).

首先我们来看看 MVC 模式需要的最小范围的信息有哪些.首先我们需要数据库的信息,就是表名,列名还有该列的数据类型,
然后我们需要一个中转,这个由 Model 来完成, Model 负责把数据库取出来的数据整理和格式化,然后输出.
数据库 ↔ Model 这一部分由 ORM 完成,并不需要自己花太多的时间, Model ↔ 这部分由各种 Java 的 Json 库来完成,
这部分是自动的,只要 JavaBean 遵循一定的规范,没有循环调用就可以顺利转换.另外我们还需要一层 Json ↔ View 的转换,
这一层花费的代码可能更多,一般都是复制粘贴的居多.并且,无可回避地,我们需要一个声明,声明所有字段的
Model field name, View field name(表头标题), type.有了这个映射我们才能够正常展示数据.

可以看出,在这个基本的例子中,除了有时候需要关联某几列处理一些业务逻辑之外,无论是数据库端,Model 层,View
层,我们做得最多的东西好像就只有两样:
1. 字段名称的映射
1. 标记字段的类型

其实这两点就是我们做的主要内容,然后我们再观察一下我们所装载的数据的流向以及所做的操作:

1. 数据库 → View
>Sql  (Object Relation Mapping)→  Model  (Object Json Mapping)→  Json  (Json View Mapping)→  View

2. View -> 数据库
>View  (Input Data)→  Json  (Object Json Mapping)→  Model  (Object Relation Mapping)→  Sql

我们发现,我们要做的就是不断的 Map, Map, 还有就是 Map,而且,也并不是没有缺点的.

主要的缺点来自 Hibernate.

1. 简单的 Hibernate 代码总是一次性地获取声明的所有字段,如果需要按需获取就需要不断地为每个不同的获取需求写构造函数
1. 1 + N 问题在 100 年以后可能还会是一个问题,一对多关系有时候可以等到查看单条记录的时候才去获取
(这里需要用 lazy 字段并且在 Json 生成的策略中也需要做一些处理),
但如果单条记录本身就是一对一关系的话这个问题就无可回避了.查询数量倍数上升直接导致性能的急剧下降.

于是你会选择 Mybatis.但选择 Mybatis 你会感觉你又回到了石器时代,一对一关系可能不会有 1 + N 问题了,但字段的
映射又成了一个问题,你可能又需要手动去映射字段了(其实最难忍受的是 Model 声明在一个地方, Sql 写在另一个地方,
然后字段映射放在第三个地方,本应高内聚的地方被搞成了声称低耦合的设计).

于是很多人便生出了一种想法:

# Why not all in one?
为什么不把映射,类型都声明在一个地方呢?这就是最初的想法.写到这里,语言被换成了 Scala.

我们再来想想,上面写到的那个例子,我们去除了所有多余的信息,多余的映射之后,我们需要的最基本信息有哪些呢?

可能真的很少,就像上面写的那样.

 id ID Long
friend.name name

| DataBase           | Model Field | Json Field | View Field | Type   |
|:------------------:|:-----------:|:----------:|:----------:|:------:|
| friend.id(AutoInc) | id          | id         | ID         | Long   |
| friend.name        | name        | name       | 姓名       | String |
| friend.nick        | nick        | nick       | 昵称       | String |

好了,多余的东西出来了,现在越来越觉得 Model Field 这一列碍眼了,可否去掉呢?答案是可以的,在下面的例子中,我直接把
Json Field 也去掉了,直接造成的结果是自带 DTO...